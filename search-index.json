[{"title":"重采样算法和 mpv 配置","date":"2024-08-18T15:00:00.000Z","url":"/posts/%E9%87%8D%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95%E5%92%8Cmpv%E9%85%8D%E7%BD%AE/","categories":[["undefined",""]],"content":"因为想好好看番，同时屏幕不是 1080p 默认的双线性缩放质量很差所以被迫学习了下。 视频相关知识是看的 vcb-s 的教程，比如压缩原理和视频瑕疵。 播放器先参考 vcb-s 的 mpv 指南，至少先把 mpv 下载下来，我用的是 iina。 重采样这些是看的 imagemagick。 重采样滤镜的对比，我觉得只能反应谁锐，PSNR 和 SSIM 都比较神秘。 上面这些全都是前置知识，不看的话会看不懂我在说什么。 重采样大概就是缩放要么做插值，先对列做然后对行做（反之的结果是一样的），比如线性 bilinear 或者三次拟合 cubic 和 spline，还有 Mitchell-Netravali 系列的。或者就是卷积，比如乘上 sinc\\text{sinc}sinc。 插值就是卷积，bilinear 和 triangle 是相同的。 满足奈奎斯特采样定律的话，sinc\\text{sinc}sinc 有可能还原出原本的曲线，sinc\\text{sinc}sinc 是理想低通滤波器。 sinc\\text{sinc}sinc 也不能直接做一整行的，不仅是性能还因为 ringing，找最近的若干个采样点做。 直接乘 sinc 会产生很强的 ringing，做了傅立叶变换之后就看得到，不加窗的旁瓣能量很大，虽然主瓣最窄也就是最锐利。窗函数 的旁瓣越小 ringing 越小，主瓣越宽越模糊。 所以要加窗，sinc windowed-sinc 就是 lanczos 算法，一般是 3tap。 也可以不行列然后做，ewa 相关算法就是直接采样圆内的点，用的是的 jinc\\text{jinc}jinc，和 sinc 强相关，二维的理想低通滤波器。jinc windowed-jinc 就是 ewa_lanczos。jinc windowed-hann 就是 ewa_hanning。这个无法保留像素哈希模式，因为正交的贡献和对角的不一样，所以可以消除锯齿等。 也许会好奇 ewa_lanczos 的距离为什么是 3.23831548416623623.23831548416623623.2383154841662362，因为这是 jinc\\text{jinc}jinc 第三个 000 的位置。 lanczos spline36 ewa_lanczos 和其变体都被认为是比较好的算法，前两适合实拍后者适合 anime。 锐的程度 ewa_lanczos4sharpest &gt; lanczos &gt; spline36 &gt; ewa_lanczossharp &gt; ewa_hanning 抗锯齿（和哈希模式排名一样，就是保留像素级别的形状） ewa_lanczossharp &gt; ewa_hanning &gt; ewa_lanczos4sharpest &gt; lanczos 最小 ringing ewa_hanning &gt; ewa_lanczossharp &gt; spline36 &gt; lanczos 我用的是 ewa_hanning，因为 &lt;2&lt;2&lt;2 的缩放比例的锐度差距不太明显，同时 ringing 和锯齿都非常讨厌。 mpv 默认是 lanczos，high-quality 是 ewa_lanczossharp，两个的 ringing 都很重又不开 anti ringing，很魔怔。 ≥2\\geq 2≥2 的缩放比例 RAVU FSRCNNX 和 anime4k 绝对会更好，虽然 anime4k 放在这里，但是它还有线条重构之类的东西。a4k 看着非常好，但是会把一些该模糊的东西也变清晰，比如制作省钱画崩的脸和路人的背景之类的，再加上我对 ai 之类的东西过敏所以没用。 视频还有色度上采样，可以参考 vcb-s 的那个教程，色度 chroma 的分辨率是亮度 LUMA 的一半。 我用的 KrigBilateral，大概是结合亮度信息作 krig 插值，效果几乎是最好的，但是人眼对色度不敏感，所以我带有心理安慰的成分。vcb-s 建议是 catmull_rom。mpv 默认的高质量非常魔怔，用的和上采样一样也是 ewa_lanczossharp。 我还是把 deband 打开了的，这也是 vcb-s 的建议。下采样我用的 spline36。 所以我的配置是 这样的配置对于我性能也足够，看 live 和 anime 都比较通用，总之我现在比较满意，也绝对不再折腾了。 更多配置可以参考官方手册。高质量的讨论可以参考升级 high-quality 默认的 issue。"},{"title":"P10656 题解","date":"2024-07-15T12:03:00.000Z","url":"/posts/P10656/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["扫描线","/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"]],"categories":[["undefined",""]],"content":" 分析 注意到一定存在包含 xxx 中 ∑j=1ixj≥∑x\\sum_{j=1}^ix_j\\geq\\sum x∑j=1i​xj​≥∑x 的第一个 iii 的最优方案。因为如果不包含，也就是 xxx 和 yyy 选择的两段都小于各自的 ∑\\sum∑，那么把 xxx 和 yyy 中 ∑\\sum∑ 大的那一个全选更优。对于 yyy 同理。 也就是已经知道常数个位置中的某个会被包含在最优方案，枚举这个位置，假设在 THU 且为 ppp，那么对于 PKU 的 [l,r][l,r][l,r] 区间，由于相同不能选，就把 THU 切成了很多段，每段都是能选的区间，而 ppp 一定被选，所以就是 ppp 所在的那段是答案。 根据 PKU 的选择区间 [l,r][l,r][l,r] 可以求出 THU 的 选择区间 [L,R][L,R][L,R]。具体的，i∈[l,r]i\\in[l,r]i∈[l,r]，THU 的 jjj 和 iii 相同 j&gt;pj&gt;pj&gt;p，R←min⁡(R,j−1)R\\leftarrow \\min(R,j-1)R←min(R,j−1)， j&gt;pj&gt;pj&gt;p，L←max⁡(L,j+1)L\\leftarrow \\max(L,j+1)L←max(L,j+1)， 那么对 PKU 做一个扫描线，需要支持前缀取 max⁡\\maxmax 和 min⁡\\minmin 和求前缀最值。显然 L,RL,RL,R 分别都是单调的，修改的都是一段区间，用线段树解决，递归到能修改才修改，复杂度为 O(log⁡n)O(\\log n)O(logn)。 代码 闲话 注意 PKU 和 THU 的第一个超过一半的位置都要算，刚好等于一半的话 i+1i+1i+1 也要计算。记录方案可以只记录一半，另一半可以之后算出来。"},{"title":"「Aqours Tree 」无旋 2-3 leafy 平衡树","date":"2024-07-05T05:23:00.000Z","url":"/posts/AqoursTree/","tags":[["平衡树","/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"]],"categories":[["undefined",""]],"content":" 概述 Aqours Tree 是我发明的无旋 2-3 leafy 平衡树。非叶子结点只会有 222 个或 333 个儿子。 每个叶子的深度相同，树高严格 ≤log⁡2\\leq \\log_2≤log2​ 且 ≥log⁡3\\geq \\log_3≥log3​，重量平衡。 支持单次 O(log⁡n)O(\\log n)O(logn) 的 split 和单次 O(log⁡a−log⁡b)O(\\log a-\\log b)O(loga−logb) 的 merge，支持可持久化，支持带势能的值域有交合并。 合并 要合并 xxx 和 yyy 这两棵 Aqours 树，xxx 的树高小于 yyy。 首先在 yyy 上找到 高度 和 xxx 一样的点 uuu。 faufa_ufau​ 有两个儿子，xxx 直接成为 yyy 的儿子 faufa_ufau​ 有三个儿子，把最左边的儿子和 faufa_ufau​ 断掉，新建一个结点连接最左边的儿子和 xxx。这产生了一个新的 Aqours 树，树高为 x+1x+1x+1。u=fauu=fa_uu=fau​ 继续操作直到 faufa_ufau​ 有两个儿子。如果直到根都不是二叉的，就产生了一个新的树高为 y+1y+1y+1 的 Aqours 树，这就是合并的结果。 否则 yyy 就是合并的结果。 对于 xxx 的树高大于 yyy 同理。 不难证明复杂度为 O(log⁡n)O(\\log n)O(logn)。 分裂 类似于 WBLT，大体来说就是把 split 路径上所有点拆开，按照分裂的标准分成两组组内合并。 由于合并的复杂度为 O(log⁡a−log⁡b)O(\\log a-\\log b)O(loga−logb)，以及 split 下来的点树高一定是有序的，所以复杂度为 O(log⁡n)O(\\log n)O(logn)。当然树高有时会 +1+1+1，但是 +1+1+1 之后根是二叉的，所以相邻两次只会有一次 +1+1+1。相同高度的也只会出现最多两次，所以 +1+1+1 永远追不上树高的增长。 代码 第一版的实现和这版的效率差距高达 4 倍，我仍在改进。 update 7.27：我不打算对这个版本做任何实现优化了，虽然这个版本的效率仍是目前最快的。 这份是更加精细的实现，但是优化已经不大了。 改进 二度化 在对三叉结点操作的时候不可避免的要进行 2 次 merge，但是没被操作的两个叉是不需要重新 merge 的，考虑「缓存」这个值。 二度化之后就起到了储存这两个叉信息的效果，期望 merge 次数变成了 1.5，理论做到和 fhqtreap 一样的 merge 次数。 具体的，对于三叉的左边两个叉或者右边，新建一个虚点连接这两个叉，然后原来的三叉点连接这个虚点。 当然也可以降低代码复杂度，因为现在就是棵正常的二叉树了。 这也增加了一般查询的复杂度，但是主要的瓶颈在 split/merge。 左偏 强制虚点在左儿子，可以降低代码复杂度，同时太不改变理论的 merge 次数. 同时不需要维护实点虚点了，每个点高度等于右儿子 +1+1+1。如果左儿子高度等于自己，自己就是三度点，同时左儿子是虚点。 代码 更新于 7.27 致谢 &amp; 杂谈 这个东西效率并不优秀，虽然我还在改进吧，但是没有任何的希望。 我目前在尝试找到一种结点编号方式，来优化缓存性能，因为其实瓶颈完全在缓存。 效率上，fhqtreap &lt;&lt; Aqours Tree &lt;= WBLT，虽然 Aqours Tree 和 WBLT 的 pushup 远少于 fhqtreap，更不说一些情况下 nodely 的等效 pushup 次数还要 ×2\\times 2×2，而差距应该是来自缓存。 我目前其实没有做到最小化 pushup 次数。 感谢 ChiFAN Kevin090228 对证明和实现提供的帮助。 也感谢 realskc 和 lxl 的审阅。 我之前就有个梦想啊，发明一个算法，然后以 Aqours 命名。 水团每个人的名字都要作为算法，永远存在下去。 更严谨的证明 ChiFAN《Aqours 树 —— wblt 的替代品》。"},{"title":"祝 Aqours 九周年","date":"2024-07-05T05:23:00.000Z","url":"/posts/%E7%A5%9DAqours%E4%B9%9D%E5%91%A8%E5%B9%B4/","categories":[["undefined",""]],"content":"很高兴能认识你们，九周年了，好厉害呢。 虽然我并没有认识你们九年，大概是在二期动画和剧场版之间吧，我看到了善子夜羽，当时应该是觉得好可爱之类的，然后就第一次见到了 Aqours。 当时我还小，肯定也不懂这份感情，我也记不清了。只记得那之后石头剪刀布我都是出的善子剪刀手（就是出食指和无名指）。 不过之后 Aqours 的三次元部分我一直都没看过，可能是太二次元了接受三次元有点困难，直到幻日的夜羽之后。嘛看来幻夜也不是一无是处。 然后彻底喜欢上了 Aqours，喜欢上了全部。到今天都会后悔自己来的太晚了，之前喜欢的程度完全不够。 「いっぱい叫んだって足りない 君へのキモチは」 说到这里啊，就再说说之前的我干啥去了吧。 最开始，我接触这个世界的第一次，是 Kizuna Ai。 今天也正好是 Kizuna Ai 的生日呢，生日快乐。 但是最后还是离我而去了。 不过今天凌晨油管直播了，说了句 coming back，然后把视频全删了，之后就一直在放之前 pv 的字符画版。 不过我不抱希望，应该又是在消费死人烂炒。 然后玩一款两个字的游戏花了比较多的时间，有点后悔。 然后我一直会听 vocaloid，中 v 的话我很喜欢五维界质，特别是海伊。 但是也离我而去了。 真的不想再经历这种事了，何况现在 Aqours 完全是我的一切，别的都无所谓了啊。 「何か始まるってことは 終わりに繋がるだなんて」 「考えてもみなかった いや 考えたくなかったんだ」 现在我对我学 OI 的答案是，只要我能拿到牌子，我就能去看 Aqours 的 live 了，我就能有很多时间和她们在一起了。 如果没有的话，以我的环境，这是完全不可能的。 在这之后干嘛，我完全没想过，不过人都是短视的，没有人会想退休之后会干什么，没有人会想死掉之后又怎么样，想了也只会陷入虚无。 所以，这肯定也算是人生的正解之一。 本来是 Aqours 的九周年，我却扯了这么多废话。我这个人，满脑子都想着自己呢。 总之，我很开心，未来还请继续下去，我也会全力应援下去。final live 什么的，请绝对不要。"},{"title":"prufer 序列","date":"2024-02-01T16:00:00.000Z","url":"/posts/prufer%E5%BA%8F%E5%88%97/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["prufer 序列","/tags/prufer-%E5%BA%8F%E5%88%97/"]],"categories":[["undefined",""]],"content":"发现标题字打错了，然后改不了标题就重新发了一遍。 简介 prufer 序列可以把一个结点带标号的树用 n−2n-2n−2 个值域为 [1,n][1,n][1,n] 的整数表示。 一棵树对应唯一的 prufer 序列，一个 prufer 序列对应唯一的树，二者为双射关系。 对树建立 prufer 序列 每次找到编号最小的 叶子结点，把这个结点的父亲放入 prufer 序列的末尾，然后删掉这个叶子。重复 n−2n-2n−2 次。 算法实现 显然可以用堆实现，也可以线性构造。 维护一个 ppp 表示最小的叶子结点，重复以下操作 删除 ppp。 如果父亲成为了叶子，且父亲的编号 &lt;p&lt;p&lt;p，删除父亲。不断重复 2 操作。 ppp 自增直到找到新的叶子结点。 分析正确性，删除一个点新成为叶子的只会是父亲，如果父亲的编号 &lt;p&lt;p&lt;p，那么父亲是现在最小的叶子；如果父亲的编号 &gt;p&gt;p&gt;p，那么父亲会在之后被找到。 ppp 只会遍历 111 到 nnn，而删除的时候每条边只会遍历一次，所以复杂度为 O(n)O(n)O(n)。 代码 对 prufer 序列建立树 prufer 序列里的点的出现次数 +1+1+1 就是结点在树上的度数。 每次找到编号最小的 度数为 111 的结点，与当前枚举的 prufer 序列的结点连边，然后这两个点度数 −1-1−1。 最后剩下两个度数为 111 的点，其中一个是 nnn，将这两个点连边。 算法实现 同理可以用堆实现，当然也可以线性构造。 现在 prufer 序列末尾添加结点 nnn，维护一个 ppp 表示最小的 度数为 111 的结点，重复以下操作 删除 ppp。 如果父亲度数变为 111 ，且父亲的编号 &lt;p&lt;p&lt;p，删除父亲。不断重复 2 操作。 ppp 自增直到找到新的度数为 111 的点。 代码 Cayley 公式 完全图 KnK_nKn​ 有 nn−2n^{n-2}nn−2 棵生成树 证明可以使用 prufer 序列，purfer 序列有 nn−2n^{n-2}nn−2 种（长度为 n−2n-2n−2 每个位置可以是 [1,n][1,n][1,n] 中的一个数），purfer 序列和生成树 一一对应，所以有 nn−2n^{n-2}nn−2 棵生成树。 类似的： nnn 个点的无根树有 nn−2n^{n-2}nn−2 种 nnn 个点的有根树有 n×nn−2n \\times n^{n-2}n×nn−2 种 nnn 个点的无根树，每个点的度数为 did_idi​，有 (n−2)!∏i−1n(di−1)!\\frac{(n-2)!}{\\prod^{n}_{i-1}(d_i-1)!}∏i−1n​(di​−1)!(n−2)!​ 种，也为 ∏i−1nCdi−1sum\\prod^{n}_{i-1}C_{d_i-1}^{sum}∏i−1n​Cdi​−1sum​（sum 为还剩下的位置） 图连通方案数 一个 nnn 个点 mmm 条边的带标号无向图有 kkk 个连通块。我们希望添加 k−1k-1k−1 条边使得整个图连通。求方案数。 感性理解一下，如果把每个连通块看成点，总方案数为 nk−2n^{k-2}nk−2。因为每个位置上填 [1,n][1,n][1,n] 都有意义。 然后每个连通块还要和上一个连边，联通块内的每一个点都可能拿出来连，所以总方案数是 nk−2×∏i=1ksin^{k-2}\\times \\prod^{k}_{i=1}s_ink−2×∏i=1k​si​。 详细证明之后再说吧。 相关题目 建 prufer 和建树：【模板】Prüfer 序列 Cayley 公式相关：[HNOI2004] 树的计数 图连通方案数：CF156D Clues"},{"title":"P9989 题解","date":"2023-12-23T16:00:00.000Z","url":"/posts/P9989/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["线段树","/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"]],"categories":[["undefined",""]],"content":"“笑って走っていく日も 泣きながら帰る日も この街と共に生きてる”——《街》 分析 操作过后的数一定至少变为原来的 12\\frac{1}{2}21​，所以问题变成了如何判断区间内是否会有数被修改。 可以维护 lcm\\text{lcm}lcm，如果 vvv 不是 lcm\\text{lcm}lcm 的倍数就说明存在数会被修改。 但是 lcm\\text{lcm}lcm 可能会很大，但是如果 lcm&gt;v\\text{lcm}&gt;vlcm&gt;v 那么 vvv 一定不是 lcm\\text{lcm}lcm 的倍数。 于是限制一个 lcm\\text{lcm}lcm 的最大值，lcm≤V\\text{lcm} \\leq Vlcm≤V 时维护具体的值，否则只维护是否 &gt;V&gt; V&gt;V。 最多会被修改 nlog⁡Vn \\log VnlogV 次，每次修改需要 O(log⁡n)O(\\log n)O(logn) 的时间去找到，因为辗转相除 lcm\\text{lcm}lcm 单点修改的总复杂度为 O(log⁡V)O(\\log V)O(logV) ，总复杂度 O(nlog⁡nlog⁡V)O(n \\log n \\log V)O(nlognlogV)。 代码 "},{"title":"P5494 题解 & 平衡树合并","date":"2023-12-21T16:00:00.000Z","url":"/posts/P5494/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["平衡树","/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["平衡树合并","/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%90%88%E5%B9%B6/"]],"categories":[["undefined",""]],"content":"这是一篇平衡树合并题解，平衡树合并的复杂度 并不是假的，本题复杂度 O(nlog⁡n)O(n \\log n)O(nlogn)，更通用的可以证明到 O(log⁡2n)O(\\log^2 n)O(log2n)，比如支持序列 全局加全局取膜。  和上面的分析相同，但受个人水平所限可能有误，还希望多多包涵，注意下文 n,Vn,Vn,V 不分。 平衡树比线段树适用性更广，常数也不大（未卡常 fhqtreap 用时 615ms）。 平衡树合并 先不考虑分裂，单说合并。 现在要合并 x,yx,yx,y 两棵树，选根节点堆值大的当根（假设是 xxx），把 yyy 的子树按照 xxx 的键值裂开（这里的裂开就是 treap 的 split），裂开的两瓣和 xxx 的左右儿子递归下去合并。 明显是把小的树裂开更优，但是堆值大大概率就是树大的，下文也默认此情况（主要是带有随机的不会分析）。 其实这里存在一个合不合并相同结点的问题，其实是 要合并 的，因为 treap 的复杂度依赖于树和堆的唯一性，如果存在相同结点那么可能会失去性质（比如全部都一样，可以在不违反树和堆的情况下出来一条链），对于一般的 treap 不存在此问题，因为自带了一个插入时间的比较。 现在分析平衡树合并的复杂度，设第一棵树大小为 aaa，第二棵为 bbb，不难发现单次合并的复杂度 上界 为 O(min⁡(a,b)log⁡(max⁡(a,b)min⁡(a,b)))O(\\min(a,b)\\log(\\frac{\\max(a,b)}{\\min(a,b)}))O(min(a,b)log(min(a,b)max(a,b)​))，大概是把小的树每个节点都拿去切割大的树，由于 finger search 所以切割复杂度为 log⁡(max⁡(a,b)min⁡(a,b))\\log(\\frac{\\max(a,b)}{\\min(a,b)})log(min(a,b)max(a,b)​)。总复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。 为什么说是上界，因为在两颗树值域重合少的时候复杂度和最少不相交的值域段数 kkk 有关，合并一次的复杂度为 O(klog⁡n)O(k \\log n)O(klogn)。 本题的复杂度分析 由于合并 kkk 段值域不相交的复杂度为 O(klog⁡n)O(k \\log n)O(klogn)，而一次 split 只会产生一段。问题是 [l,x][x+1,y][y+1,r][l,x][x+1,y][y+1,r][l,x][x+1,y][y+1,r] 如果先合并 [l,x][y+1,r][l,x][y+1,r][l,x][y+1,r] 再合并 [x+1,y][x+1,y][x+1,y] 会产生额外的一次 O(log⁡n)O(\\log n)O(logn)，但是合并次数等于分裂次数，所以总复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。 更通用的复杂度分析 定义势能为 φ(T)=∑log⁡(vi+1−vi)\\varphi(T)=\\sum\\log(v_{i+1}-v_i)φ(T)=∑log(vi+1​−vi​)，也就是 TTT 相邻的两个值的差的 log⁡\\loglog 之和。 合并 AAA 和 BBB，有 kkk 段值域： &lt;−d1−&gt; &lt;−−d2−−&gt; &lt;−−d3−−&gt; &lt;−−−d4−−−&gt;A={[−−a1−−] [−a2−] [−−a3−−]}B={ [−−−b1−−−] [−b2−]}\\begin{aligned} &amp;\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{&lt;-d_1-&gt;}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{&lt;--d_2--&gt;}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{&lt;--d_3--&gt;}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{&lt;---d_4---&gt;}\\\\ &amp;A = \\{_{[--a_1--]}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{[-a_2-]}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{[--a_3--]}&amp;\\}\\\\ &amp;B = \\{\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{[---b_1---]}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ _{[-b_2-]}&amp;\\} \\end{aligned} ​ &lt;−d1​−&gt;​ &lt;−−d2​−−&gt;​ &lt;−−d3​−−&gt;​ &lt;−−−d4​−−−&gt;​A={[−−a1​−−]​ [−a2​−]​ [−−a3​−−]​B={ [−−−b1​−−−]​ [−b2​−]​​}}​ 形如 [−−−−−]_{[-----]}[−−−−−]​ 的是一段值域，形如 &lt;−−di−−&gt;_{&lt;--d_i--&gt;}&lt;−−di​−−&gt;​ 的是值域之间的距离且距离为 did_idi​。 合并后 Δφ=φ(A)+φ(B)−φ(A∪B)\\Delta\\varphi=\\varphi(A)+\\varphi(B)-\\varphi(A\\cup B)Δφ=φ(A)+φ(B)−φ(A∪B)，有 Δφ=log⁡(d1+b1+d2)+log⁡(d2+a2+d3)+⋯+log⁡(dk−1+ak2+dk)−(log⁡d1+⋯+log⁡dk)\\Delta\\varphi=\\log(d_1+b_1+d_2)+\\log(d_2+a_2+d_3)+\\dots+\\log(d_{k-1}+a_{\\frac{k}{2}}+d_k)-(\\log d_1+\\dots+\\log d_k) Δφ=log(d1​+b1​+d2​)+log(d2​+a2​+d3​)+⋯+log(dk−1​+a2k​​+dk​)−(logd1​+⋯+logdk​) 前面的把 log⁡(+ai+)\\log(+a_i+)log(+ai​+) 的放在一起就是根据定义算的 φ(A)\\varphi(A)φ(A)，后面的则是由于两段值域不交合并会产生新的势能，势能大小为 log⁡\\loglog 值域的距离也就是 log⁡(di)\\log(d_i)log(di​)。 显然有 Δφ≥log⁡(d1+d2)+log⁡(d2+d3)+⋯+log⁡(dk−1+dk)−(log⁡d1+⋯+log⁡dk)\\Delta\\varphi\\geq\\log(d_1+d_2)+\\log(d_2+d_3)+\\dots+\\log(d_{k-1}+d_k)-(\\log d_1+\\dots+\\log d_k) Δφ≥log(d1​+d2​)+log(d2​+d3​)+⋯+log(dk−1​+dk​)−(logd1​+⋯+logdk​) 因为 log⁡\\loglog 函数是下凸的，可得 log⁡(a+b2)≥log⁡a+log⁡b2\\log(\\frac{a+b}{2})\\geq \\frac{\\log a+\\log b}{2}log(2a+b​)≥2loga+logb​，把 log⁡\\loglog 里的 12\\frac{1}{2}21​ 拿出来可得 log⁡(a+b)≥1+log⁡a+log⁡b2\\log(a+b)\\geq 1+\\frac{\\log a+\\log b}{2} log(a+b)≥1+2loga+logb​ 那么把 log⁡(di−1+di)\\log(d_{i-1}+d_i)log(di−1​+di​) 全部拆开，可得 Δφ≥k−1−d1+dk2\\Delta\\varphi\\geq k-1-\\frac{d_1+d_k}{2} Δφ≥k−1−2d1​+dk​​ 忽略常数可得 Δφ≥k−O(log⁡V)\\Delta\\varphi\\geq k-O(\\log V) Δφ≥k−O(logV) 也就是说最多做 nlog⁡Vn \\log VnlogV 次 split，总复杂度为 O(nlog⁡Vlog⁡n)O(n \\log V \\log n)O(nlogVlogn)。 带有分裂的复杂度分析 一次分裂会减少 log⁡V\\log VlogV 的势能，split 是不增加势能的。 一次合并如果增加就至多增加 log⁡V\\log VlogV 的势能（原因可以看上面的式子）。 那么最多就只有 nlog⁡Vn\\log VnlogV 的势能，而 Δφ\\Delta \\varphiΔφ 最大就是把这些势能都减少完，所以总复杂度为 O(nlog⁡nlog⁡V)O(n \\log n \\log V)O(nlognlogV)。 代码 全局加全局取膜 全局加不影响势能。 如果取模的过程中把树分成了 kkk 段，合并后产生了至多 (k−1)log⁡v(k-1) \\log v(k−1)logv 的势能，但是 vvv 也会变成 vk\\dfrac{v}{k}kv​。把 log⁡v\\log vlogv 提到外面来，显然每轮最劣的 kkk 都是一样的，因为这是一个递归的问题。原问题变成了 kkk 使得 klog⁡knk\\log_k nklogk​n 最大。解得最小值取 eee，最大值为 nnn。所以增加的势能最大为 nlog⁡vn \\log vnlogv。 所以总复杂度为 O(nlog⁡nlog⁡v)O(n \\log n\\log v)O(nlognlogv)。 通用性 确实这东西很能拓展，只要不咋影响势能都可以把合并当作基本操作，比如加、除、取膜、开根、翻转。 其实全局取膜作用与值域区间也是对的，值域区间完全可以把它当成两个独立的序列分别操作后再 merge 起来，分别操作也就是 (n−m)log⁡v+mlog⁡v=nlog⁡v(n-m)\\log v+m \\log v= n\\log v(n−m)logv+mlogv=nlogv，完全不影响。最后只是常数段的 merge 新增的 log⁡v\\log vlogv 的势能。所以只会增加总共 nlog⁡vn \\log vnlogv 的势能。别的同理。"},{"title":"Blog 索引","date":"2023-12-20T16:00:00.000Z","url":"/posts/Blog%E7%B4%A2%E5%BC%95/","tags":[["索引","/tags/%E7%B4%A2%E5%BC%95/"]],"categories":[["undefined",""]],"content":"君のこころは輝いてるかい？ Part A知识\\LARGE \\mathscr Part\\ \\rm A\\quad\\LARGE\\textbf{知识}Part A知识 基本都是我乱写的。 为了便于挑选文章，下面有几种标记 ： ⊚\\color{blue}\\large\\circledcirc⊚ 意为 内容完善 ⊚\\color{red}\\large\\circledcirc⊚ 意为 内容简略/尚不完整 ⊝\\color{purple}\\large\\circleddash⊝ 意为 施工中/内容不严谨 ✓\\checkmark✓ 意为 推荐 †\\dag† 意为 过时/可能存在错误 数据结构 可持久化线段树 ⊚\\color{red}\\large\\circledcirc⊚ 整体二分 ⊚\\color{red}\\large\\circledcirc⊚ †\\dag† dsu on tree⊚\\color{red}\\large\\circledcirc⊚ 平衡树合并⊚\\color{blue}\\large\\circledcirc⊚ ✓\\checkmark✓ 数学 异或线性基 ⊚\\color{blue}\\large\\circledcirc⊚ fmt&amp;fwt 图论 联通性相关 ⊚\\color{blue}\\large\\circledcirc⊚ 网络流常见建模 ⊝\\color{purple}\\large\\circleddash⊝ 圆方树 ⊚\\color{red}\\large\\circledcirc⊚ prufer 序 ⊚\\color{blue}\\large\\circledcirc⊚ 动态规划 杂 高维前缀和/sosdp ⊚\\color{blue}\\large\\circledcirc⊚ 切比雪夫距离与曼哈顿距离 ⊚\\color{blue}\\large\\circledcirc⊚ ✓\\checkmark✓ Part B记录\\LARGE \\mathscr Part\\ \\rm B\\quad\\LARGE\\textbf{记录}Part B记录 等我写了 200 道就发出来。 Part C杂\\LARGE \\mathscr Part\\ \\rm C\\quad\\LARGE\\textbf{杂}Part C杂 也许是文化课相关内容，或者是我感兴趣的一些研究，再者就是杂谈。"},{"title":"切比雪夫距离与曼哈顿距离","date":"2023-12-11T16:00:00.000Z","url":"/posts/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["曼哈顿&切比雪夫","/tags/%E6%9B%BC%E5%93%88%E9%A1%BF-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB/"]],"categories":[["undefined",""]],"content":"内含高维曼哈顿-切比雪夫转换。 定义 曼哈顿距离：∣x1−x2∣+∣y1−y2∣|x_1-x_2|+|y_1-y_2|∣x1​−x2​∣+∣y1​−y2​∣ 切比雪夫距离：max⁡(∣x1−x2∣,∣y1−y2∣)\\max(|x_1-x_2|,|y_1-y_2|)max(∣x1​−x2​∣,∣y1​−y2​∣) 更多距离 欧几里得距离：(x1−x2)2+(y1−y2)2\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(x1​−x2​)2+(y1​−y2​)2​ LmL_mLm​ 距离：(∣x1−x2∣m+∣y1−y2∣m)1m(|x_1-x_2|^m+|y_1-y_2|^m)^{\\frac{1}{m}}(∣x1​−x2​∣m+∣y1​−y2​∣m)m1​ nnn 维欧几里得距离：∑i=1n(di1−di2)2\\sqrt{\\sum_{i=1}^n(d_{i1}-d_{i2})^2}∑i=1n​(di1​−di2​)2​ nnn 维曼哈顿距离：∑i=1n∣di1−di2∣\\sum_{i=1}^n|d_{i1}-d_{i2}|∑i=1n​∣di1​−di2​∣ nnn 维切比雪夫：max⁡i=1n∣di1−di2∣\\max_{i=1}^n|d_{i1}-d_{i2}|maxi=1n​∣di1​−di2​∣ 转换 曼哈顿转切比雪夫：(x,y)→(x+y,x−y)(x,y)\\rightarrow(x+y,x-y)(x,y)→(x+y,x−y) 切比雪夫转曼哈顿：(x,y)→(x+y2,x−y2)(x,y)\\rightarrow(\\frac{x+y}{2},\\frac{x-y}{2})(x,y)→(2x+y​,2x−y​) 证明 证明可以用几何，因为曼哈顿坐标系是通过切比雪夫坐标系旋转 45∘45^\\circ45∘ 后，再缩小到原来的一半得到的。 或者纯代数，x≤yx\\leq yx≤y 时 ∣x−y∣=x−y|x-y|=x-y∣x−y∣=x−y，x&lt;yx&lt;yx&lt;y 时 ∣x−y∣&gt;x−y|x-y|&gt;x-y∣x−y∣&gt;x−y，转换成 (x+y,x−y)(x+y,x-y)(x+y,x−y) 之后 max⁡(∣x1−x2∣,∣y1−y2∣)\\max(|x_1-x_2|,|y_1-y_2|)max(∣x1​−x2​∣,∣y1​−y2​∣) 一定是原来的 ∣x1−x2∣+∣y1−y2∣|x_1-x_2|+|y_1-y_2|∣x1​−x2​∣+∣y1​−y2​∣ 都取到绝对值的时候，也就是曼哈顿距离，而 max⁡(∣x1−x2∣,∣y1−y2∣)\\max(|x_1-x_2|,|y_1-y_2|)max(∣x1​−x2​∣,∣y1​−y2​∣) 就是切比雪夫距离。 其实是转换成 (x,y),(−x,y),(x,−y),(−x,−y)(x,y),(-x,y),(x,-y),(-x,-y)(x,y),(−x,y),(x,−y),(−x,−y)，因为切比雪夫本身有绝对值所以正负效果是一样的，去掉重复一半的就是上面的式子。 切比雪夫转曼哈顿其实就是解 {x+y=ax−y=b\\begin{cases}x+y=a\\cr x-y=b\\end{cases}{x+y=ax−y=b​ 的方程。 高维切比雪夫和曼哈顿 通过上面的证明可以得到，kkk 维曼哈顿可以转换为 2k−12^{k-1}2k−1 维的切比雪夫。 也就是指定每一位取正还是取负，在去掉重复的 12\\frac{1}{2}21​。 但是高维切比雪夫却不一定都能转换为曼哈顿，因为本质这个转换是解方程，拿四维切比雪夫 (a,b,c,d)(a,b,c,d)(a,b,c,d) 举例 {x+y+z=a−x+y+z=bx−y+z=cx+y−z=d\\begin{cases} x+y+z=a\\cr -x+y+z=b\\cr x-y+z=c\\cr x+y-z=d \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​x+y+z=a−x+y+z=bx−y+z=cx+y−z=d​ 这个方程需要满足 a=b+c+da=b+c+da=b+c+d 才能有解，有解情况下 {x=a−b2y=a−c2z=a−d2\\begin{cases} x=\\frac{a-b}{2}\\cr y=\\frac{a-c}{2}\\cr z=\\frac{a-d}{2} \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​x=2a−b​y=2a−c​z=2a−d​​ 而切比雪夫不是 2k2^k2k 维的情况下我们可以升维成 2k2^k2k 维，这个时候补 000 也有可能使得方程一定有解。 比如求 ∑i=1n∑j=1i−1max⁡(ai−aj,bi−bj,ci−cj)−min⁡(ai−aj,bi−bj,ci−cj)\\sum_{i=1}^n\\sum_{j=1}^{i-1}\\max(a_i-a_j,b_i-b_j,c_i-c_j)-\\min(a_i-a_j,b_i-b_j,c_i-c_j) i=1∑n​j=1∑i−1​max(ai​−aj​,bi​−bj​,ci​−cj​)−min(ai​−aj​,bi​−bj​,ci​−cj​) 可以直接 min-max 容斥，但是跑的慢 推式子 max⁡(ai−aj,bi−bj,ci−cj)−min⁡(ai−aj,bi−bj,ci−cj)=max⁡(∣bi−bj−(ai−aj)∣,∣ci−cj−(bi−bj)∣,∣ai−aj−(ci−cj)∣)=max(∣(bi−aj)+(bj−aj)∣,∣(ci−bi)+(cj−bj)∣,∣(ai−ci)+(aj−cj∣))\\begin{aligned} &amp;\\max(a_i-a_j,b_i-b_j,c_i-c_j)-\\min(a_i-a_j,b_i-b_j,c_i-c_j)\\cr =&amp;\\max(|b_i-b_j-(a_i-a_j)|,|c_i-c_j-(b_i-b_j)|,|a_i-a_j-(c_i-c_j)|)\\cr =&amp;max(|(b_i-a_j)+(b_j-a_j)|,|(c_i-b_i)+(c_j-b_j)|,|(a_i-c_i)+(a_j-c_j|)) \\end{aligned} ==​max(ai​−aj​,bi​−bj​,ci​−cj​)−min(ai​−aj​,bi​−bj​,ci​−cj​)max(∣bi​−bj​−(ai​−aj​)∣,∣ci​−cj​−(bi​−bj​)∣,∣ai​−aj​−(ci​−cj​)∣)max(∣(bi​−aj​)+(bj​−aj​)∣,∣(ci​−bi​)+(cj​−bj​)∣,∣(ai​−ci​)+(aj​−cj​∣))​ 这明显是一个三维切比雪夫，给他升成四维，令 a=0a=0a=0，刚好满足 a=b+c+da=b+c+da=b+c+d，所以原式为 12∑i=1n∑j=1i−1∣bi−ai∣+∣ci−bi∣+∣ai−ci∣\\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^{i-1}|b_i-a_i|+|c_i-b_i|+|a_i-c_i| 21​i=1∑n​j=1∑i−1​∣bi​−ai​∣+∣ci​−bi​∣+∣ai​−ci​∣ 这个直接排序就能求了。 补充 其实不把重复的去掉，保留 2k2^k2k 维，这样就不用取 abs\\text{abs}abs 了，能有比切比雪夫更好的性质。"},{"title":"P2120 题解","date":"2023-11-04T16:00:00.000Z","url":"/posts/P2120/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["斜率优化","/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"],["李超树","/tags/%E6%9D%8E%E8%B6%85%E6%A0%91/"]],"categories":[["undefined",""]],"content":"“生きてく意味があると感じるよ…確かに！”——《Nameless Love Song》 分析 首先写个 n2n^2n2 dp 转移 fi=min⁡j=1i−1(fj+∑k=j+1i(xi−xk)pk)+ci=min⁡j=1i−1(fj+xi∑k=j+1ipk−∑k=j+1ixkpk)+ci=min⁡j=1i−1(−xi∑k=1jpk+fj+∑k=1jxkpk)+xi∑k=1ipk−∑k=1ixkpk+ci\\begin{aligned} f_i&amp;=\\min_{j=1}^{i-1}(f_j+\\sum_{k=j+1}^i(x_i-x_k)p_k)+c_i\\\\ &amp;=\\min_{j=1}^{i-1}(f_j+x_i\\sum_{k=j+1}^ip_k-\\sum_{k=j+1}^ix_kp_k)+c_i\\\\ &amp;=\\min_{j=1}^{i-1}(-x_i\\sum_{k=1}^jp_k+f_j+\\sum_{k=1}^jx_kp_k)+x_i\\sum_{k=1}^ip_k-\\sum_{k=1}^ix_kp_k+c_i \\end{aligned} fi​​=j=1mini−1​(fj​+k=j+1∑i​(xi​−xk​)pk​)+ci​=j=1mini−1​(fj​+xi​k=j+1∑i​pk​−k=j+1∑i​xk​pk​)+ci​=j=1mini−1​(−xi​k=1∑j​pk​+fj​+k=1∑j​xk​pk​)+xi​k=1∑i​pk​−k=1∑i​xk​pk​+ci​​ 然后 min⁡\\minmin 里面的像一次函数，直接上李超树。 一些细节 要特判末尾连续的 pi=0p_i=0pi​=0，以及第 888 个点卡李超树，别的 hack 倒是不用管。 代码 "},{"title":"聊聊 dsu on tree","date":"2023-10-30T16:00:00.000Z","url":"/posts/dsu_on_tree/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["dsu on tree","/tags/dsu-on-tree/"]],"categories":[["undefined",""]],"content":"契约签订完毕，接下来要认真起来了。 简介 对于子树查询类问题，大多可以 dfs 序然后上数据结构，不行就树上莫队。 一个方法是 dsu on tree，是一个好写的复杂度 O(nlog⁡n)O(n \\log n)O(nlogn) 离线算法。 过程 考虑启发式，对于每个节点找出重子树，然后 递归询问所有轻子树（询问后删除贡献） 递归询问重子树（保留贡献） 加入所有轻子树内节点的贡献 证明 对于复杂度，总操作次数为 n+∑n+\\sumn+∑ 轻子树大小。类似于树链剖分，每个点被多操作一次就代表成为了一次轻子树，而轻子树的父亲的子树大小至少为轻子树的 222 倍，所以每个点至多被操作 log⁡\\loglog 次。 性质 加入重儿子之前的全局所有贡献都是被删掉了的。 这意味着 dsu on tree 和 O(n2)O(n^2)O(n2) 去统计在贡献处理上没有任何区别，也意味着回滚莫队能做的都能做。 题目 CF600E Lomsat gelral 直接 dsu on tree，求众数和可以正常做，撤销的时候不仅要把计数的数组撤销，还要把最多出现次数和众数和撤销，后者也好办，操作前记录一个撤销的时候直接赋值就好了。 CF741D Arpa’s letter-marked tr… 排序后能是回文串要么每个字符都是偶数，或者只有一个为奇数。 字符只有 222222 个，可以记录某些字符出现奇数的最长长度，然后类似于点分治去统计。 把这个过程按照 dsu on tree 做就好了。 CF1767F Two Subtrees 如果只询问一个子树，那么就是 dsu on tree 板子。 考虑把 dsu on tree 序列化，先加入轻子树，再加入重子树，再加入根。 当扫描这个序列的所有子树时，轻子树的移动后会直接被删掉，重子树移动后再查询根，重子树会被保留同时加入所有轻子树，扫描的复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。 直接在这个序列上莫队，区间的左右端点为询问的两颗子树。 子树询问的区间移动就如果目标区间当前区间无交就当前区间删除然后暴力加入目标区间，否则就就正常移动左右端点。"},{"title":"真·浅谈线性基","date":"2023-09-18T16:00:00.000Z","url":"/posts/%E7%BA%BF%E6%80%A7%E5%9F%BA/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["线性基","/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"]],"categories":[["undefined",""]],"content":"或许是该努努力了呢，快要来不及了。 异或线性基 简单来说，线性基是一个数的集合，每个序列都拥有一个线性基，线性基中的若干个数异或起来原序列中的任意一个数。 重要性质： 原序列中的任意一个数都能通过线性基中的若干个数异或得到。 线性基内任意数异或和不为 000。 一个序列的所有线性基大小相同。 别的性质： 由 nnn 个数组成的大小为 sss 的线性基，能构成 2s2^s2s 种不同的数，每个数出现 2n−s2^{n-s}2n−s 次。 基本操作 插入 求异或最大值 求异或最小值 如果是序列内部最小的异或值，那么如果有元素不能被插入线性基，最小值为 000，否则为线性基中最小的元素。 如果是丢一个数进去的话，类似于求异或最大值做就行了。 查询存在性 能插入进去就是不存在，否则就是存在。 求 kkk 小值 先预处理，对于线性基 ddd，如果 di(0≤i&lt;n)d_i(0 \\leq i &lt; n)di​(0≤i&lt;n) 的二进制位 j(0≤j&lt;i)j(0 \\leq j &lt; i)j(0≤j&lt;i) 为 iii，did_idi​ 异或上 djd_jdj​。 线性基求并 把一个线性基的全部元素插入另一个就行。 例题 P3857 [TJOI2008] 彩灯 一个序列若干数异或得到的集合和这个序列的线性基异或得到的集合是一样的。 由于线性基性质 2，一个大小为 sss 的线性基能异或得到 2s2^s2s 个数。 那么算出这个序列的线性基，答案就为 2s2^s2s。 P4570 [BJWC2011] 元素 因为线性基性质 2，线性基内任意数异或和不为 000，考虑线性基。 因为线性基性质 3，无论顺序能放进去的总个数是不变的，贪心的先放贡献大的就行。 P5556 圣剑护符 距离 &gt;30&gt;30&gt;30 的路径是一定存在一个子集异或值为 000 的，因为这样线性基一定会被插满。 那么对于 ≤30\\leq 30≤30 的暴力用线性基判断，用树剖和线段树维护 lca 和修改。 P4151 [WC2011] 最大XOR和路径 走的路径一定是一条链然后走到了一些别的地方又回来。 一个路径走两遍就没了贡献，那么有贡献的一定是走到了环，并且贡献为环本身，因为走去环回来这条路径被走了两遍。 这样的话所有的环都能自由选择，把所有的小环的异或值加入线性基（大环相当于小环的异或值），就相当于自由选择所有的环。 考虑选择走的 1→n1\\rightarrow n1→n 链，链可以随便选，因为如果有多条链，一定都构成了环，那么选择构成的那个环就相当于选择了另一条链。 把选择的链的异或值去线性基里跑最大异或值就行了。CF845G 就是跑最小值。 P5607 [Ynoi2013] 无力回天 NOI2017 首先这是个数据结构套线性基础，考虑线段树，但是修改是区间修改线性基不太好做。 差分，bi=ai xor aib_i=a_i\\ \\text{xor}\\ a_ibi​=ai​ xor ai​，把区间修改变为单点修改。 aia_iai​ 可以用 b1 xor b2… xor bib_1\\ \\text{xor}\\ b_2 \\dots \\ \\text{xor}\\ b_ib1​ xor b2​… xor bi​ 表示出来，那么 al…ara_l\\dots a_ral​…ar​ 的所以子集异或都能用 al bl+1…bra_l\\ b_{l+1} \\ldots b_ral​ bl+1​…br​ 表示出来。 用线段树维护 bbb 的线性基，同时用树状数组维护 bbb 的前缀异或和来求 ala_lal​。 询问就求出 bl+1…brb_{l+1}\\dots b_rbl+1​…br​ 插入 ala_lal​ 然后求异或最大值，特判 l=rl=rl=r。 线性基合并的复杂度为 O(log⁡2V)O(\\log^2V)O(log2V)，所以总复杂度为 O(nlog⁡nlog⁡2V)O(n \\log n \\log^2 V)O(nlognlog2V)。 P3292 [SCOI2016] 幸运数字 因为是算异或最大值，求的是树上路径线性基，倍增直接做是 log⁡mlog⁡2V\\log m \\log^2 Vlogmlog2V 的。 发现 线性基重复部分没有贡献，类似于 max⁡,gcd⁡\\max,\\gcdmax,gcd 这些，然后直接用 st 表那种做法做。 具体的，先倍增预处理线性基。对于询问找到 lca 之后拆成 x→lcax \\rightarrow lcax→lca 和 y→lcay \\rightarrow lcay→lca 两条链。对于一条链 x→yx\\rightarrow yx→y，倍增找到 uuu 使得 depu−depy+1=2⌊log⁡(depx−depy+1)⌋−1dep_u-dep_y+1=2^{\\lfloor \\log({dep_x-dep_y+1}) \\rfloor-1}depu​−depy​+1=2⌊log(depx​−depy​+1)⌋−1，复杂度瓶颈在于合并线性基的 O(log⁡V)O(\\log^V)O(logV)，找 uuu 的 O(log⁡n)O(\\log n)O(logn) 无所谓。 复杂度为 O(nlog⁡2V+nlog⁡3n)O(n \\log^2 V+n \\log^3 n)O(nlog2V+nlog3n)，nnn 比 VVV 小足以通过。 P4869 albus就是要第一个出场 由 nnn 个数组成的大小为 sss 的线性基，能构成 2s2^s2s 种不同的数，每个数出现 2n−s2^{n-s}2n−s 次。 查询排名就是从低位到高位看，如果第 iii 位存在线性基且查询的数 qqq 二进制的第 iii 为 111，记 ccc 为 [0,i)[0,i)[0,i) 的线性基个数，排名加上 2c2^c2c。 因为是第 iii 位存在线性基，相当于强制选了第 iii 位，这样就不会算重。 不会证明，之后再补吧。"},{"title":"真·浅谈高维前缀和/sosdp","date":"2023-09-18T16:00:00.000Z","url":"/posts/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["高维前缀和","/tags/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"]],"categories":[["undefined",""]],"content":"夜空是否全然知晓？ 高维前缀和/sosdp 计算高维前缀和可以不用容斥，而是对每一维分别做前缀和，复杂度为 O(kn)O(kn)O(kn)，其中 kkk 是维度。 对于子集求和问题，相当于二进制下的 111 可以选 000 或 111，000 只能选 000，类似于一个高维的前缀和问题。 那么就可以在 O(n2n)O(n 2^n)O(n2n) 的复杂度之内求出类似于子集和的问题。 题目 ARC100E Or Plus Max i∈k,j∈ki \\in k,j \\in ki∈k,j∈k 是 i∣j=ki | j = ki∣j=k 的必要条件，是 i∣j&lt;=ki|j&lt;=ki∣j&lt;=k 的充分条件。 先算出 =k=k=k 的答案，在求个前缀最小值就算出了 ≤k\\leq k≤k 的答案，然后也满足了充要。 然后就是求子集最大值和次大值，高维前缀和解决。 CF1208F Bits And Pieces 考虑枚举一个 iii，然后 di∣(dj&amp;dk)=di+(di&amp;dj&amp;dk)d_i|(d_j \\&amp; d_k)=d_i+(d_i \\&amp; d_j \\&amp; d_k)di​∣(dj​&amp;dk​)=di​+(di​&amp;dj​&amp;dk​)。 要使得 di&amp;dj&amp;dkd_i \\&amp; d_j \\&amp; d_kdi​&amp;dj​&amp;dk​ 更大，从高位到低位贪心的看能不能是 111。 假设当前选择的为 sss，首先 di∈sd_i \\in sdi​∈s，然后存在 j,kj,kj,k 使得 i&lt;j&lt;ki &lt; j &lt; ki&lt;j&lt;k 并且 dj∈s,dk∈sd_j \\in s,d_k \\in sdj​∈s,dk​∈s。 相当于求一个超集的最大值和次大值，这种类似子集和的问题可以用高维前缀和解决。 P6442 [COCI2011-2012#6] KOŠARE 设选择的集合为 sss，fsf_sfs​ 为 ∈s\\in s∈s 的个数，那么集合 ∈s\\in s∈s 的个数为 2fs−12^{f_s}-12fs​−1。 fsf_sfs​ 可以用高维前缀和算，然后按照 111 的个数容斥就行了。 也可以再跑一遍差分。 CF449D Jzzhu and Numbers 和上一道类似，不过不是跑子集是跑超集。 然后跑容斥或者差分。"},{"title":"整体二分浅谈","date":"2023-08-31T16:00:00.000Z","url":"/posts/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["整体二分","/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"]],"categories":[["undefined",""]],"content":"浅浅的总结一下简单情况。 适用范围 可以使用整体二分解决的题目需要满足以下性质： 询问的答案具有可二分性 修改对判定答案的贡献互相独立，修改之间互不影响效果 修改如果对判定答案有贡献，则贡献为一确定的与判定标准无关的值 贡献满足交换律，结合律，具有可加性 题目允许使用离线算法 许昊然《浅谈数据结构题几个非经典解法》 一般来说适用于二分时每次 check 都要预处理，同时预处理代价较大的情况。 把所有询问一起二分，对于一个 check 就只需要预处理一次。 特殊情况的处理 查询 比如区间第 kkk 小，就和平衡树上类似的，如果不在 [l,mid][l,mid][l,mid] 里的，kkk 要减去 [l,mid][l,mid][l,mid] 小于它的个数。 修改 把修改和询问都视为操作（修改要满足上面的性质）。 比如带修改区间第 k 大，修改为把 xxx 位置上的数改成 yyy，当 mid≥ymid\\geq ymid≥y 时用树状数组在 xxx 这里 −1-1−1 表示删除。 二维化 把初始的的都视作修改就能轻松处理。 类似 P1527 [国家集训队] 矩阵乘法。 优化 相比每次都撤销 [l,mid][l,mid][l,mid] 内的所有预处理，维护一个 ppp 表示 [1,p][1,p][1,p] 已经被预处理，然后类似莫队的区间移动去把 ppp 移动到 midmidmid，这样加入和撤销的次数会少一半。 然后有些预处理操作不用撤销可以换成区间操作，就能少一个 log⁡\\loglog。"},{"title":"P4732 题解","date":"2023-07-09T16:00:00.000Z","url":"/posts/P4732/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["可持久化线段树","/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"]],"categories":[["undefined",""]],"content":"“这样的我会被谁拯救吗 你发现了吧” —— 《月光掌》 分析 设第 iii 次撤销操作要撤销的是 jjj，那么 iii 到 jjj 的操作中不存在优先级比 jjj 小的，所以 jjj 到 iii 的操作不会在没撤销 iii 的情况下被撤销。 考虑可持久化线段树，维护操作的优先级，撤销操作 iii 直接继承 j−1j-1j−1 的线段树，查询 jjj 直接线段树上二分。 代码 "},{"title":"网络流常见建模","date":"2023-07-03T16:00:00.000Z","url":"/posts/joi2015ho_d/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"]],"categories":[["undefined",""]],"content":"你眼中倒映的世界 一瞬永远 —— 《梦语》 分析 首先答案有单调性，考虑二分。 然后每次留下来的构成一颗三叉树，父亲是儿子的中位数，考虑树形 dp。 上很经典的中位数套路，设二分的值为 vvv，≥v\\geq v≥v 的 gvg_vgv​ 为 111，&lt;v&lt; v&lt;v 的 gvg_vgv​为 −1-1−1。 如果儿子的值之和 &gt;0&gt;0&gt;0 那么父亲就 ≥v\\geq v≥v。 考虑设 fuf_ufu​ 为 gu&gt;0g_u &gt; 0gu​&gt;0 时最小的子树的叶子中 ≥v\\geq v≥v 的个数。 转移为 fu=∑fv−max⁡fvf_u = \\sum f_v -\\max f_vfu​=∑fv​−maxfv​，因为如果 gu&gt;0g_u &gt; 0gu​&gt;0 必须有两个及以上的 gv=1g_v=1gv​=1，多了没用所以是选择最小的的两个 fvf_vfv​。 如果 froot≤f_{root} \\leqfroot​≤ 序列中 ≤v\\leq v≤v 的个数就是可行的。 代码 "},{"title":"网络流常见建模","date":"2023-06-29T16:00:00.000Z","url":"/posts/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E8%A7%81%E5%BB%BA%E6%A8%A1/","tags":[["网络流","/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"本文主要讲建图方法，定义和证明内容较少。 正好网络流二十四题做完了整理下。 目录 网络流模型 最大流最小割 最小割树 平面图最小割 费用流 SSP 算法 有负圈的费用流 上下界建模 无源汇上下界可行流 有源汇上下界可行流 有源汇上下界最大/小流 经典问题 二分图 二分图最大匹配 二分图最小点覆盖 二分图最大独立集 路径覆盖与链覆盖 DAG 最小路径覆盖 DAG 最小链覆盖 DAG 最长反链 最大权闭合子图 最大密度子图 各种建模 拆点 分层图 最大流相关 最小割相关 最小割离散变量模型（切糕） 费用流相关 杂 区间问题常见建模 网络流模型 最大流最小割 最大流 = 最小割是网络流中的重要结论，运用最大流和最小割可以解决一些复杂度划分问题。 最小割树 主要解决 多次询问 无向图两点之间的最小割的问题。 一个 NNN 个点的图上，两点之间只有 NNN 中本质不同的最小割。因此一定存在一棵树，满足树上两点的最小割等于原图上两点的最小割。我们把这样的树称之为 最小割树。 Gomory-Hu 算法 考虑分治，在所有点中任取两个作为源汇点求出最小割，划分成两个互不连通的割集。对这两个点连边，边权为求出来的最小割。然后对与两个割集递归下去做。同时每次的最小割都是对于全局跑的， 询问两个点之间的最小割，就是求这两个点在最小割树上的路径中最小的边。可以用倍增实现。 参考&amp;例题 P4897【模板】最小割树 证明见 Eznibuil 博客 平面图最小割 平面图最小割 = 对偶图最短路。 平面图 如果图 GGG 能画在平面 SSS 上，且除顶点外无边相交，则称 GGG 可平面嵌入 SSS，GGG 可称为可平面图或平面图，画出的没有边相交的图称为 GGG 的平面表示或平面嵌入。 对偶图 设 GGG 是平面图的某一个平面嵌入，构造图 G∗G^*G∗： 在 GGG 的每个面放 RiR_iRi​ 置 G∗G^*G∗ 的一个顶点 v∗v^*v∗。 设 eee 为 GGG 的一条边，若 eee 在 GGG 的面 RiR_iRi​ 和 RjR_jRj​ 的公共边上，做 G∗G^*G∗ 的边 e∗e^*e∗ 与 eee 相交，且 e∗e^*e∗ 连接 G∗G^*G∗ 的顶点 vi∗,vj∗v_i^*,v_j^*vi∗​,vj∗​，即 e∗=(vi∗,vj∗)e^*=(v_i^*,v_j^*)e∗=(vi∗​,vj∗​)，e∗e^*e∗ 不与其他边相交。若 eee 为 GGG 中的桥且在 RiR_iRi​ 的边界上，则 e∗e^*e∗ 是以 RiR_iRi​ 中顶点 vi∗v_i^*vi∗​ 为端点的环，即 e∗=(vi∗,vj∗)e^*=(v_i^*,v_j^*)e∗=(vi∗​,vj∗​)。 形象化的说，对偶图就是把平面图的每条边 旋转了 909090 度。 对偶图的性质 G∗G^*G∗ 为平面图，且为平面嵌入。 GGG 中自环对应 G∗G^*G∗ 桥，GGG 中桥对应 G∗G^*G∗ 自环。 G∗G^*G∗ 是连通的。 若 GGG 的面 Ri,RjR_i,R_jRi​,Rj​ 的边界上至少有两条公共边，则关联 vi∗,vj∗v_i^*,v_j^*vi∗​,vj∗​ 的边有平行边，G∗G^*G∗ 多半是多重图。 同构的图的对偶图不一定是同构的。 G∗∗G^{**}G∗∗ 与 GGG 同构当且仅当 GGG 是连通图。 平面图最小割 = 对偶图最短路 参考&amp;例题 P2046 [NOI2010] 海拔 oi-wiki 费用流 可以解决一些需要最优化的问题。 SSP 算法 每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。 如果图上存在单位费用为负的圈，SSP 算法正确无法求出该网络的最小费用最大流。 设该网络的最大流为 fff ，则最坏时间复杂度为 O(nmf)O(nmf)O(nmf)。SSP 算法是 伪多项式时间 的。 实现 只需将 EK 算法或 Dinic 算法中找增广路的过程，替换为用最短路算法寻找单位费用最小的增广路即可。 参考&amp;例题 P7173【模板】最小费用最大流 oi-wiki 有负圈的费用流 由于存在最短路，所以费用流算法不能直接做费用有负圈的图。 消圈算法本身就有消除负圈的过程，但是效率低下。 对于网络中的负费用边 (x,y)(x,y)(x,y)，强制满流。然后加入 (y,x)(y,x)(y,x)，费用为原来费用的相反数，用于退流。 跑有源汇上下界最小费用最大流即可。 例题 P7173 【模板】有负圈的费用流 上下界建模 上下界网络流本质是给流量网络的每一条边设置了流量上界 c(u,v)c(u,v)c(u,v) 和流量下界 b(u,v)b(u,v)b(u,v) 。也就是说，一种可行的流必须满足 b(u,v)≤f(u,v)≤c(u,v)b(u,v) \\leq f(u,v) \\leq c(u,v)b(u,v)≤f(u,v)≤c(u,v) 。同时必须满足除了源点和汇点之外的其余点流量平衡。 无源汇上下界可行流 先假设每条边已经流了 b(u,v)b(u,v)b(u,v) 的流量，在新图中加入流量为 c(u,v)−b(u,v)c(u,v)-b(u,v)c(u,v)−b(u,v) 的边。 最大流需要满足初始流量平衡条件，但是构造出来的初始流很有可能不满足初始流量平衡。 假设一个点初始流入流量减初始流出流量为 MMM，同时建立附加源点 S′S&#x27;S′ 和附加汇点 T′T&#x27;T′： M=0M=0M=0 流量平衡 M&gt;0M&gt;0M&gt;0 入流量大，SSS 向其连流量为 MMM 的边 M&lt;0M&lt;0M&lt;0 出流量大，其向 TTT 连流量为 −M-M−M 的边 如果附加边满流，说明这一个点的流量平衡条件可以满足，否则这个点的流量平衡条件不满足。 在建图完毕之后跑 S′S&#x27;S′ 到 T′T&#x27;T′ 的最大流，若 S′S&#x27;S′ 连出去的边全部满流，则存在可行流，否则不存在。 有源汇上下界可行流 设源点为 sss，汇点为 ttt。添加一条 ttt 到 sss 的上界为 ∞\\infty∞ 下界为 000 的边。 注意这里的源汇点已被视为普通点，与超级源汇点不同的。 有源汇上下界最大/小流 最大流 先找到可行流，然后删去附加边 t→st \\rightarrow st→s，在残留网络上跑最大流。 将可行流流量和最大流流量相加即为答案。 最小流 先在没加附加边的网络上跑最大流，再对残量网络加入附加边 t→st \\rightarrow st→s，最小流即为附加边的流量。 例题 最大流：P5192 Zoj3229 Shoot the Bullet|东方文花帖|【模板】有源汇上下界最大流 最小流：P4843 清理雪道 经典问题 二分图 二分图最大匹配 将源点连上左边所有点，右边所有点连上汇点，容量dou为 111。原来的每条边从左往右连边，容量也皆为 111，最大流即最大匹配。 如果用 Dinic 算法求最大流，时间复杂度为 nm\\sqrt{n}mn​m。 二分图最小点覆盖 最小点覆盖：选最少的点，满足每条边至少有一个端点被选。 König 定理：最小点覆盖 === 最大匹配。 二分图最大独立集 最大独立集：选最多的点，满足两两之间没有边相连。 二分图中，最大独立集 =n −=n\\ -=n − 最小点覆盖。 因为在最小点覆盖中，任意一条边都被至少选了一个顶点，所以对于其点集的补集，任意一条边都被至多选了一个顶点，所以不存在边连接两个点集中的点，且该点集最大。 参考 oiwiki 路径覆盖与链覆盖 DAG 最小路径覆盖 DAG 最小路径覆盖：尽可能少的不相交的路径（链）覆盖掉所有节点。 考虑把单个结点也看成一条路径，相邻结点合并路径条数就会减少，所以要最大化可以合并的个数。 因为是最大化合并，考虑 二分图最大匹配 ，把每个点拆成 u′u&#x27;u′ 和 u′′u&#x27;&#x27;u′′，原图上边 u→vu \\rightarrow vu→v 就在新图上连一条 u′→v′′u&#x27; \\rightarrow v&#x27;&#x27;u′→v′′，跑二分图最大匹配，就是最大的可合并的点数，总点数减去大的可合并的点数就是最小路径覆盖。 DAG 最小链覆盖 DAG 最小链覆盖：尽可能少的的路径（链）覆盖掉所有节点，可以相交。 最小链覆盖与最小路径覆盖非常相近，考虑将最小链覆盖转化为最小路径覆盖。 用 Floyd 求出原图的传递闭包，直接在传递闭包上跑最小路径覆盖即可。 传递闭包：这里简单理解为对于所有联通的点对连边的新图 DAG 最长反链 反链：点的集合满足任意 x,yx,yx,y，x,yx,yx,y 互不连通 Dilworth 定理：最小链覆盖大小 === 最长反链长度。 最大权闭合子图 闭合子图：对于点集 SSS，任意 u∈Su\\in Su∈S，uuu 的出边的另一个点也属于 SSS。 最大权闭合子图：点权和最大的闭合子图。 最大权闭合子图 === 正权和 −-− 最小割 例题 P2762 太空飞行计划问题 P3410 拍照 最大密度子图 最大密度子图：闭合子图使得 ∣E∣∣V∣\\frac{|E|}{|V|}∣V∣∣E∣​ 最大。 一般情况下，我们使用 01 分数规划 解决最大密度子图问题。 二分比值 vvv，建图 SSS 到 iii 连容量为 mmm 的边 iii 到 TTT 连容量为 m+2∗v−degim+2*v-deg_im+2∗v−degi​ 的边 原图上的边容量为 111 如果流量 =n×m=n\\times m=n×m 就存在密度为 ≥v\\geq v≥v 的子图。 一般来说二分的 epsepseps 不能设太小，不然无法判断边是否有流量。 例题 UVA1389 Hard Life 各种建模 拆点 本质上是将点的限制转化为边的限制。"},{"title":"APIO2023 赛博乐园","date":"2023-05-26T16:00:00.000Z","url":"/posts/APIO2023/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["最短路","/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"]],"categories":[["undefined",""]],"content":"“并没有 不一样 为何感到悲伤” —— 《尘降》 分析 首先把图反着跑，这样总通行时间除以 222 就变成了后续时间都除以 222，当前总通过时间为 000 就变成了后续时间都为 000。 然后把一个点拆开成 K+2K+2K+2 个，第 iii 个代表经过 iii 次除以二操作的点，最后一个代表经过清零操作的点，然后跑最短路。 注意一下 HHH 不能多次经过和不能达到为 −1-1−1，这样就有 979797 分了。 发现除以二操作做 log⁡2105×10910−6\\log_2 \\frac{10^5\\times10^9}{10^{-6}}log2​10−6105×109​ 次就会变成可以忽略的值，所以 KKK 和 707070 取小的那一个就行。 代码 闲话 考试的时候用的是 505050 过了，死过以内。"},{"title":"ABC241G 题解","date":"2023-05-23T16:00:00.000Z","url":"/posts/AT_abc241_g/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["网络流","/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"],["最大流","/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"]],"categories":[["undefined",""]],"content":" 分析 枚举第一名，假设以后的比赛该名玩家都获胜，然后判定是否合法。 数据范围很网络流，考虑最大流，流量代表得分，然后是建图： 源点和每场比赛连容量为 111 的边 比赛如果有胜负就向胜者连边，否则就向参与比赛的两个人连边 设第一名的得分为 www，第一名向汇点连容量为 www 的边，其余的人得分不能超过第一名，所以其余的人向汇点连容量为 w−1w-1w−1 的边 由于总场次为 n(n+1)2\\frac{n(n+1)}{2}2n(n+1)​，如果最大流为 n(n+1)2\\frac{n(n+1)}{2}2n(n+1)​ 就说明每场比赛都分出了胜负，这种情况合法。 代码 "},{"title":"APIO2023 线上游记","date":"2023-05-23T16:00:00.000Z","url":"/posts/P4698/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"“请告诉我为何心不停的跳动 这颗心究竟装着什么” —— 《人偶之梦》 分析 注意到 pi&lt;pjp_i&lt;p_jpi​&lt;pj​ 则 ci≤cjc_i\\leq c_jci​≤cj​，存在偏序关系。 一个贪心的想法是，按照订单的 vvv 从大到小，每次找到大于 ddd 的最小的 ppp 住进去。 但是如果房间已经被占用，就住进大于 ddd 的 ppp 最小的没有被占用的房间，而不是把占用清除。 考虑这样为什么是对的，设占用房间的为 iii，要住进去的为 jjj。 如果 i,ji,ji,j 都要入住，答案无影响。 如果 i,ji,ji,j 只有一个要入住，因为 vi&gt;vjv_i&gt;v_jvi​&gt;vj​，所以 iii 肯定比 jjj 更优，jjj 必定不会被选到（就选选的不是最优的房间也不影响）。 现在问题变成了，找到大于 ddd 的 ppp 最小的没有被占用的房间，然后把这个房间删除，multiset 可以解决（注意房间可重，set 不可重）。 代码 闲话 pi&lt;pjp_i&lt;p_jpi​&lt;pj​ 则 ci≤cjc_i\\leq c_jci​≤cj​ 放在题面更合理吧，放在数据范围有点抽象。"},{"title":"APIO2023 线上游记","date":"2023-05-22T16:00:00.000Z","url":"/posts/apio2023%E7%BA%BF%E4%B8%8A%E6%B8%B8%E8%AE%B0/","tags":[["游记","/tags/%E6%B8%B8%E8%AE%B0/"]],"categories":[["undefined",""]],"content":" day-? 报名被报成线上了，寄寄寄。 day-? P 和我的年龄给了我可能今年唯一能看的成绩。 day 0 麦会炸，是那种嘶吼声的回音的感觉。 字符串，感觉自己没学过了。 直播能很好看到旷课人数，很震撼，签到更震撼。 同时知道了 线上没监考。 线下看起来好好玩，你们发在 LA 群里的自拍是在同情我吗，你们玩音游的真多，我也想玩，你们发在 LA 里的 kfc 是在同情我吗，华山饭店好厉害，你们带带我行不。 然后一遍听中v曲一边改之前 apio 的题，自信啊，那不得保底 Ag。 day 1 T1 板到不行，半小时就写好了。 这是什么，cms，刷新一下。 这是什么，OJ，交一下。 啥情况就不说了，结束前半小时才知道我 T1 过了（一个小时 debug 一次），我 K 和 50 取 min 还能过很厉害啊，想不通。 T2 不会，32 分不说了，ai≤3a_i\\leq 3ai​≤3 的随便搞几下就过了（当然也是在考试后知道的）。777 分的暴力写挂了（同上）。 T3 电路，可是我去的 P，加法器没写出来。 能不能下次复刻光追，求求你了。 结束了。 day 2 听到了 200 一车，早就知道了，我考的相当烂，我无法改变。 晚上在阳台吹了一晚上风。 以为自己打铁打的，结果线上 Ag 了（那 777 分挺可惜的，不然线上 Au 了）。 一看线下 Cu 130，别的不评价了，没资格评价。 闭幕式之后的表演环节没直播，但是知道了好玩的事。 上半年这就是最后一场比赛的，本来说能买个 D 的，结果感觉我穿越到平行世界了。 结束了，感觉最近精神状态一直不太好，空落落的。"},{"title":"ABC299G 题解","date":"2023-04-24T16:00:00.000Z","url":"/posts/AT_abc299_g/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"]],"categories":[["undefined",""]],"content":"“まだ動くまだ進む 物語の上を泳げ” —— 《スイマー》 分析 维护一个栈，每次加入一个值。 如果栈顶在之后也会出现并且比加入的值大就弹出。 这样使得每个值尽可能放在前面。 粗略的证明一下。假设有两个序列 A,BA,BA,B，AAA 的字典序小于 BBB，且 AAA 是字典序最小的。 AAA 的第一个与 BBB 不同的位置为 xxx，AxA_xAx​ 在 BBB 中出现的位置 yyy 一定在 xxx 之后。 ByB_yBy​ 能移动到 xxx，在处理 BBB 的时候 ByB_yBy​ 会被移动到 xxx，所以不会找到 BBB 序列。 那么找到的序列是字典序最小的。 不过一个排列的置换字典序最小不一定代表这个排列的字典序最小。 代码 "},{"title":"P4200 题解","date":"2023-04-16T16:00:00.000Z","url":"/posts/P4200/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["平衡树","/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"]],"categories":[["undefined",""]],"content":"“遥か月を目指した 今日の空は 彼方西に流れた もう届かないや 届かないや”——《回る空うさぎ》 分析 首先对于每个坐标开一颗平衡树，要维护的东西需要全局取 max，但是自己不能取。 士气值和团结值在一个点没加进去之前是好算的，直接是坐标内部的点威武值的最大值和点的个数。 然后就是要更新坐标上的所有点，先给平衡树的根节点打上标记，打完之后再把点加进去。 现在这个点的标记就不会打在自己身上了。 代码 后话 至少 2023.04.17 我还是最优解。"},{"title":"ABC295G 题解","date":"2023-03-26T16:00:00.000Z","url":"/posts/AT_abc295_g/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"],["并查集","/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"],["强连通","/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A/"]],"categories":[["undefined",""]],"content":"“「あるべき人間の姿へ」 「正しい人間の姿へ」 そう思えばなんだか 人間全てが汚く思えてくるな”—— 《不可解》 题意简述 给定一张点数为 NNN 的有向图，初始 pi(1≤pi≤i,1≤i&lt;N)p_i(1\\leq p_i \\leq i,1 \\leq i &lt; N)pi​(1≤pi​≤i,1≤i&lt;N) 连向 i+1i+1i+1。 QQQ 次操作，有两种： 1 u v：uuu 向 vvv 连一条有向边，保证最开始时 vvv 能到达 uuu，u≠vu \\ne vu=v。 2 x：询问 xxx 能到达的点中编号最小的点。 分析 最开始时，uuu 能到达的所有点都比 uuu 大。而操作 111 形成了一个强联通分量，走强联通分量内部的点才可能达到更小的点。 一个点 xxx 能达到的最小的点在 xxx 所在的强连通分量里，用并查集维护即可。 代码 闲话 警惕 abc 打普及 G 牌。"},{"title":"圆方树","date":"2023-03-21T16:00:00.000Z","url":"/posts/%E5%9C%86%E6%96%B9%E6%A0%91/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["圆方树","/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"],["仙人掌","/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C/"],["图论","/tags/%E5%9B%BE%E8%AE%BA/"]],"categories":[["undefined",""]],"content":"模拟赛考到了，正好写一下。 简介 圆方树是一种将图变成树的方法，解决一些路径连通性相关的东西或者是仙人掌。 描述 前置知识：点双连通分量。以下不考虑孤立点。 在圆方树中，原来的点为圆点，点双为方点。每个点双内部是一个菊花图 [1]，多个菊花图通过原图中的割点连接在一起。 圆方树有 n+cn+cn+c 个点，ccc 为原图中点双连通分量的个数。如果原图有 kkk 个联通分量，那么圆方树会是有 kkk 颗树的森林。 性质 圆方树有优美的性质。 无论如何换根，圆方树形态不变 圆方树的子树 = 原仙人掌的子仙人掌 相同种类的点不会相连 算法 在找点双的时候，新找到一个点双就新建一个方点，与点双内部所有点连边即可。 题目 无向图相关 [APIO2018] 铁人两项 建出圆方树，枚举中转点 ccc 统计答案。 ccc 为圆点，ccc 的每一个儿子 vvv 子树内的点都能和其他子树内的点组成合法的 (s,f)(s,f)(s,f)，贡献为 sizev×(sizec−sizev−1)size_v \\times (size_c-size_v-1)sizev​×(sizec​−sizev​−1)（sizesizesize 是原本的树的大小）。 ccc 为方点，计算的是以这个点双中的某个点作为 ccc，(s,f)(s,f)(s,f) 中至少有一个点在点双内，且没有被圆点统计到的答案。(s,f)(s,f)(s,f) 中有一个点在点双内，共有 degc−1deg_c-1degc​−1 种，但是在割点出被圆点统计到了一次，所以有 degc−2deg_c-2degc​−2 种。 用换根 DP 也统计父亲的答案就行了。 CF487E Tourists 经过的点双的并就是所有可能路径的并，也就是问经过的所有点双中边权的最小值。 建圆方树，查询可以用树剖解决，问题在修改。 修改时计算更新所有相连的方点是不行的，菊花图就可以卡掉。 一个圆点的贡献挂到父亲上，父亲一定是方点。但是这样点双会缺一个点，缺的是深度最小的圆点，这个点被计算到了上方的点双里。 查询 x,yx,yx,y 经过的点双除了包含 lca(x,y)lca(x,y)lca(x,y) 的一定都能覆盖完全，缺的只有 lca(x,y)lca(x,y)lca(x,y)。单独贡献 lca(x,y)lca(x,y)lca(x,y) 即可，如果 lca(x,y)lca(x,y)lca(x,y) 是方点则贡献 falca(x,y)fa_{lca(x,y)}falca(x,y)​。 对每个方点维护一个 multiset，查询用树剖 + 线段树求最小值。 存在一个点为支配点，其余点之间没有边相连，则这个图为菊花图（简单来说就是存在一个点与所有点相连，其余的点之间没有边）。 ↩︎ "},{"title":"ABC279F 并查集题解","date":"2023-03-19T16:00:00.000Z","url":"/posts/AT_abc294_f/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"],["并查集","/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"]],"categories":[["undefined",""]],"content":"“我仍然在无人问津的阴雨霉湿之地” —— 《世末歌者》 题意 高橋君有 NNN 瓶糖水，青木君有 MMM 瓶糖水。 高橋君的第 iii 瓶糖水有 AiA_iAi​ 份糖 BiB_iBi​ 份水。 青木君的第 iii 瓶糖水有 CiC_iCi​ 份糖 DiD_iDi​ 份水。 将两人的糖水各选一瓶混合有 NMNMNM 种可能，求其中浓度第 kkk 大的糖水浓度是多少。 有 xxx 份糖和 yyy 份水的糖水浓度是 100xx+y%\\dfrac{100x}{x+y}\\%x+y100x​%。 分析 二分浓度 ccc 后，我们只需要得到混合后浓度大于等于 ccc 的个数。 有 aaa 份糖 bbb 份水的糖水，再加 (a+b)c−a(a+b)c-a(a+b)c−a 份糖就能变成浓度 ccc，也可能是减掉糖。 令 (a+b)c−a(a+b)c-a(a+b)c−a 为 sss，sss 的正负可以判断浓度和 ccc 的关系。 那么两瓶糖水 x,yx,yx,y 混合后，判断 sx+sys_x+s_ysx​+sy​ 的正负即可。 因为 (Ax+Bx+Cy+Dy)c−Ax−Cy=(Ax+Bx)c−Ax+(Cy+Dy)c−Cy=sx+sy(A_x+B_x+C_y+D_y)c-A_x-C_y=(A_x+B_x)c-A_x+(C_y+D_y)c-C_y=s_x+s_y(Ax​+Bx​+Cy​+Dy​)c−Ax​−Cy​=(Ax​+Bx​)c−Ax​+(Cy​+Dy​)c−Cy​=sx​+sy​，所以 sss 是可加的。 二分浓度，将青木君糖水的 sss 排序，枚举高橋君的糖水，二分计算混合后浓度大于等于 ccc 的个数。 复杂度 O(nlog⁡nlog⁡v)O(n \\log n \\log v)O(nlognlogv)。 代码 "},{"title":"可持久化线段树 basic!","date":"2023-03-14T16:00:00.000Z","url":"/posts/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/","tags":[["线段树","/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["可持久化线段数","/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%95%B0/"],["可持久化","/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"]],"categories":[["undefined",""]],"content":"都是典中典，我之前还不是很会。 简介 对于一颗正常的线段树，如果要支持所有版本都既可以访问又可以修改（完全可持久化），对于每个版本保存一颗线段树是不可接受的。 发现每次修改操作修改的点的个数只有 log⁡n\\log nlogn 个，于是通过记录根节点保存插入后修改的节点和未修改的节点，就可以实现可持久化。 区间问题 大概就是两个区间范围限制，一个用值域搞掉，一个用根节点搞掉。 静态区间第 k 大 考虑全局第 k 大怎么用线段树做，对值域建线段树，然后在线段树上二分。如果问题为求 [1,r][1,r][1,r] 的第 k 大，那么找到插入 rrr 时的版本就行了。 回到原问题，发现我们统计的信息是前缀和，在二分时将 [1,l−1][1,l-1][1,l−1] 和 [1,r][1,r][1,r] 的相减就行了。 带修区间第 k 大 和静态一样，利用前缀和的性质。暴力修改前缀和是不可接受的，考虑用树状数组维护主席树的根节点，每次取出树状数组的 log⁡n\\log nlogn 个节点计算前缀和即可。 时间复杂度 O(nlog⁡2n)O(n \\log^2 n)O(nlog2n)，空间 O(nlog⁡n)O(n \\log n)O(nlogn)。 树上主席树 板子 在树上用主席树做一个前缀和的东西，和区间类似，拿着 x,y,lca(x,y),fa(lca(x,y))x,y,lca(x,y),fa(lca(x,y))x,y,lca(x,y),fa(lca(x,y)) 去二分即可。 异或/可持久化trie 相关 平移后的异或问题 其实就是区间操作的典题，不过用了可持久化 trie 的思想。 从高到底枚举 bbb 的第 iii 位，如果区间内存在 [b+2ci xor1−x,b+2ci xor1−x+2k−1][b+2^{c_i \\ xor 1}-x,b+2^{c_i \\ xor 1}-x+2^k-1][b+2ci​ xor1−x,b+2ci​ xor1−x+2k−1] 之间的数，那么 b xor(a+x)b \\ xor (a+x)b xor(a+x) 的这一位可以为 111，因为这个区间里的数加 xxx 后第 iii 位都是 ci xor1c_i \\ xor 1ci​ xor1。 可持久化 trie 是个和可持久化线段树差不多的东西。 "},{"title":"ARC158C 题解","date":"2023-03-12T16:00:00.000Z","url":"/posts/AT_arc158_c/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"]],"categories":[["undefined",""]],"content":"“かけがえのない日々を ここで 積みかさねて ひとつひとつ いまさらわかった”—— 《想いよひとつになれ》 题意简述 设 f(x)f(x)f(x) 为 xxx 的数字和。例如 f(158)=1+5+8=14f(158)=1+5+8=14f(158)=1+5+8=14。 给定一个长度为 NNN 的正整数序列 AAA，求 ∑i=1N∑j=1Nf(Ai+Aj)\\sum_{i=1}^{N}\\sum_{j=1}^{N}f(A_i+A_j)∑i=1N​∑j=1N​f(Ai​+Aj​)。 分析 设 g(a,b)g(a,b)g(a,b) 为 a+ba+ba+b 进位的次数，则 f(a+b)=f(a)+f(b)−9×g(a,b)f(a+b)=f(a)+f(b)-9 \\times g(a,b)f(a+b)=f(a)+f(b)−9×g(a,b)，其中 ∑i=1N∑j=1Nf(Ai)+f(Aj)=2n×∑i=1Nf(Ai)\\sum_{i=1}^{N}\\sum_{j=1}^{N}f(A_i)+f(A_j)=2 n \\times \\sum_{i=1}^{N} f(A_i)∑i=1N​∑j=1N​f(Ai​)+f(Aj​)=2n×∑i=1N​f(Ai​)。 考虑如何计算 ∑i=1N∑j=1Ng(Ai,Aj)\\sum_{i=1}^{N}\\sum_{j=1}^{N}g(A_i,A_j)∑i=1N​∑j=1N​g(Ai​,Aj​)。对于两个数 x,yx,yx,y，如果 x+yx+yx+y 在第 ddd 位上有进位，当且仅当 x mod 10d+y mod 10d≥10d+1x \\bmod 10^d+y \\bmod 10^d \\geq 10^{d+1}xmod10d+ymod10d≥10d+1。将所有 Ai mod 10dA_i \\bmod 10^dAi​mod10d 排序，枚举 ddd 和 AjA_jAj​ 去二分 Ai mod 10dA_i \\bmod 10^dAi​mod10d 中大于 10d+1−Aj mod 10d10^{d+1}-A_j \\bmod 10^d10d+1−Aj​mod10d 的值的个数即可。 代码 "},{"title":"联通性相关","date":"2023-03-12T16:00:00.000Z","url":"/posts/%E8%81%94%E9%80%9A%E6%80%A7%E7%9B%B8%E5%85%B3/","tags":[["强连通","/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["图论","/tags/%E5%9B%BE%E8%AE%BA/"],["点双连通","/tags/%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A/"],["边双连通","/tags/%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A/"]],"categories":[["undefined",""]],"content":"发现这部分学的最烂，稍微整理下。 强连通分量 定义 强连通的定义：有向图 GGG 强连通，当且仅当 GGG 的任意两个节点联通。 强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图。 Tarjan 算法 DFS 生成树 有向图的 DFS 生成树主要有 444 种边： 树边：是搜索时找到一个未访问的结点形成的边。 返祖边：是搜索时找到自己的祖先形成的边。 横叉边：是搜索时找到已遍历过的结点形成的边，并且这个节点不是自己的祖先和子树中的结点。 前向边：是搜索时找到子树中的结点形成的边。 DFS 生成树与强连通分量之前的关系 如果 uuu 是某个强连通分量在 DFS 生成树里搜到的第一个结点，这个强连通分量其它的结点一定在 uuu 的子树里。结点 uuu 被称为这个强连通分量的根。 证明：假设强连通分量其它的结点不都在 uuu 的子树里，那么不在的那些结点一定与 uuu 连有返祖边或者前向边，返祖边或者前向边相连的点都是遍历过的，所以该假设不成立。 Tarjan 算法求强连通分量 维护对于每个结点 uuu 维护两个值： dfnudfn_udfnu​ 表示结点 uuu 是第几个被搜到的。 lowulow_ulowu​ 表示在 uuu 的子树中能够回溯到的最早出现在栈中的结点。具体的，lowulow_ulowu​ 为以 uuu 为根的子树的和子树中通过一条不在搜索树上的边能到达的结点的 dfndfndfn 的最小值。 按照深度优先搜索依次搜索每个值，对于每个值维护 dfndfndfn 和 lowlowlow。每找到一个强连通分量，就将这个强连通分量全部出栈（该强连通分量的所有元素都在栈顶）。在搜索过程中对于 uuu 与其相连的结点 vvv（vvv 不是 uuu 的父亲）： vvv 未被访问过：继续对 vvv 进行搜索，用 lowvlow_vlowv​ 更新 lowulow_ulowu​，因为 vvv 能够回溯到的点 uuu 一定也能回溯到。 vvv 被访问过且在栈中：根据定义，用 dfnvdfn_vdfnv​ 更新 lowulow_ulowu​。 vvv 被访问过且不在栈中：说明 vvv 已经被处理，不做更新。 代码实现 割点和桥 定义 对于一张无向图，如果删去一个点后这张图的联通分量增加了，那么这个点是这张图的割点。 对于一张无向图，如果删去一条边后这张图的联通分量增加了，那么这条边是这张图的桥。 Tarjan 算法求割点 dfs 记录时间戳 lowlowlow，同时记录每个结点不经过父亲能到达的结点最小的时间戳 lowlowlow。 判断一个点 uuu 是割点的依据是存在儿子vvv 满足 lowv≤dfnulow_v \\leq dfn_ulowv​≤dfnu​。因为如果 lowv≥dfnulow_v \\geq dfn_ulowv​≥dfnu​，说明 vvv 一定有一条返祖边或者横叉边，删掉 uuu 之后 vvv 仍然与 uuu 的父亲联通，否则删到 uuu 之后 vvv 不连通，出现新的联通分量。 这个判定唯一不适用于 uuu 是根节点。因为根节点的儿子不可能与根节点的父亲联通（根节点没有父亲），所以如果根节点是割点，那么在 dfs 树中存在两个以上的儿子就一定是割点，删掉根结点后根结点的子树一定不连通。 代码实现 Tarjan 算法求割边 和求割点差不多，不需要特殊处理根节点。 lowulow_ulowu​ 为不经过 u−vu-vu−v 这条边能到达的结点的最小时间戳。当 lowv&gt;dfnulow_v &gt; dfn_ulowv​&gt;dfnu​ 时，u−vu-vu−v 这条边是割边。 因为 lowv=lowulow_v = low_ulowv​=lowu​ 就证明 vvv 可以通过别的边到达 uuu。 代码实现 双连通分量 定义 在一张无向图中，对于两个点 u,vu,vu,v，如果删去任意一条边都不能使其不连通，那么 uuu 和 vvv 是 边双连通 的。 在一张无向图中，对于两个点 u,vu,vu,v，如果删去任意一个点都不能使其不连通，那么 uuu 和 vvv 是 点双连通 的。 边双连通具有传递性，点双连通没有。 Tarjan 算法求点双连通 与边双连通不同，一个点可能属于多个点双连通分量。 除了独立点，所有点双连通都有两个以上的点构成。我们用栈维护点，当遇到割点或根节点时，将子树内目前不属于其它点双的非割点或在子树中的割点归到一个新的点双。注意这个点可能还是与其它点双的公共点，所以不能将其出栈。 代码实现 Tarjan 算法求边双连通 删掉割边所剩下的就是边双连通分量。割边用 Tarjan 求即可。 代码实现 "},{"title":"根号数据结构","date":"2023-02-20T16:00:00.000Z","url":"/posts/%E6%A0%B9%E5%8F%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":[["莫队","/tags/%E8%8E%AB%E9%98%9F/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["分块","/tags/%E5%88%86%E5%9D%97/"]],"categories":[["undefined",""]],"content":"很久之前写的烂尾笔记 根号数据结构 简介 顾名思义，复杂度含 O(n)O(\\sqrt n)O(n​) 的数据结构叫根号数据结构，一般都运用了分块和分值的思想。 分块 简介 分块的基本思想是，通过对原数据的适当划分，并在划分后的每一个块上预处理部分信息，从而较一般的暴力算法取得更优的时间复杂度，或和其他算法搭配平衡出更优的时间复杂度。 使用分块进行维护对数据的特征要求较少 可以维护很多线段树无法维护的东西。 设块长为 sss ,复杂度 O(n/s)O(n/s)O(n/s)， sss 取 n\\sqrt nn​ 时最优，复杂度为 O(n)O(\\sqrt n)O(n​) 。 缺点是 O(n)O(\\sqrt n)O(n​) 的复杂度比 O(log⁡n)O(\\log n)O(logn) 满了不少 但是在部分问题上分块在复杂度或者常数上优于 O(log⁡2n)O(\\log ^2 n)O(log2n) 的树套树解法。 分类 序列分块 对于一个序列按每 sss 个元素进行分块，通过修改零散块内元素和修改整块元素去解决问题。 通常修改块内元素为暴力修改之后更新整块信息，修改整块元素则是以区间标记的形式修改。 值域分块 在值域上按每 sss 个元素进行分块，通过修改零散块内元素时修改整块元素去解决问题。 因为在值域本就存在一维偏序关系，即数据是有序的，所以可以依据序列分块的思想去解决问题。 通常用来平衡复杂度，例如 O(1)O(1)O(1) 修改 O(n)O(\\sqrt n)O(n​) 查询的全局最大值。 询问分块 对于每 sss 个询问进行分块，即一次处理 sss 个元素，同时进行 n/sn/sn/s 次全局维护操作。 通常用于需要较大时间维护全局，但是可以以较小时间进行单次查询的问题，也是平衡复杂度的思想。 其他 例如块状链表等等。 莫队 简介 一种通过暴力移动端点去离线解决区间问题的方法。发明者为国集队长莫涛，所以被称为莫队。 算法发现过程 (大概?) 查询一个区间可以暴力的从左端点扫到右端点。当我们有两个区间 [l1,r1][l_1,r_1][l1​,r1​] 和 [l2,r2][l_2,r_2][l2​,r2​] 需要查询时且 [l1,r1]∩[l2,r2]≠∅[l_1,r_1] \\cap [l_2,r_2] \\ne \\emptyset[l1​,r1​]∩[l2​,r2​]=∅ 时，我们可以在扫描完 [l1,r1][l_1,r_1][l1​,r1​] 之后继续从左到右扫描 (r1,r2](r_1,r_2](r1​,r2​]，同时撤销从左到右撤销 [l1,l2)[l_1,l_2)[l1​,l2​)。这种方式确实减少了扫描次数，但可以轻松构造数据使复杂度为 O(n2)O(n^2)O(n2)。 考虑分块的思想，限制端点移动范围。设块长为 SSS ,对于 lll 在同一块内放在一起操作，同时按 rrr 从小到大排序。这样 lll 在一次操作内最多移动 SSS 次，rrr 在同一块内最多移动 nnn 次，所以 lll 的移动次数为 m⋅Sm \\cdot Sm⋅S，rrr 的移动次数为 n2S\\dfrac{n^2}{S}Sn2​，这样复杂度为 O(mS+n2S)O(mS+\\dfrac{n^2}{S})O(mS+Sn2​)。 可证在最优的情况下 SSS 为 nm\\dfrac{n}{\\sqrt m}m​n​ 时最优。事实上如果对块长的设定不准确将会对复杂度造成很大影响，例如当 mmm 与 n\\sqrt nn​ 同阶时，若将块长误设成 n\\sqrt nn​，复杂度将为nnn \\sqrt nnn​。 一些细节 莫队可以维护的数据需要支持在区间头或者尾加上或者删除,(也有不需要支持删除的莫队，详见回滚莫队)，比线段树之类的数据结构适用性更加更加广泛。 一般的莫队不支持修改 (也有支持修改的莫队，详见带修莫队)。 莫队是一种离线算法，对于强制在线的题目和信息学竞赛之外的方面应该没有啥用途。 板子题 小B的询问 [国家集训队] 小 Z 的袜子 分类 带修莫队 回滚莫队 莫队配合分块/bitset 带修莫队 简介 一般的莫队是无法支持修改的，因为一般无法做到在区间内修改快速更新 (要是可以就不需要莫队了)。及解决方法和 dp 类似，我们可以加一个维度。落实到带修莫队就是加一个时间维度，区间变为[l,r,time][l,r,time][l,r,time]。 转移和普通莫队一样转移，但是我们的排序多了一个关键字，以 O(n23)O(n^{\\frac{2}{3}})O(n32​) 为一块，总复杂度为 O(n53)O(n^{\\frac{5}{3}})O(n35​)。 板子题 [国家集训队] 数颜色 / 维护队列 回滚莫队 简介 莫队配合分块 / bitse 板子题 曼哈顿交易 P3730 莫队+值域分块题解 "},{"title":"ABC290G 题解","date":"2023-02-19T16:00:00.000Z","url":"/posts/AT_abc290_g/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["atcoder","/tags/atcoder/"]],"categories":[["undefined",""]],"content":"“空高く舞う鳥へ かさねたハート”—— 《Jump up HIGH!!》 题意简述 有一颗深度为 DDD 的满 KKK 叉树，你需要剪掉一些边使其存在大小为 XXX 的联通分量，求最少剪掉的边的条数。 分析 考虑选择 所有 大小大于等于 XXX 的一颗深度为 ddd 的满 KKK 叉树，在剪掉后大小仍超过 XXX 的情况下剪掉所有与根直接相连的边，也就是剪掉若干个深度为 d−1d-1d−1 的满 KKK 叉树，再递归处理深度 d−1d-1d−1 的满 KKK 叉树。注意如果 d≠Dd \\ne Dd=D，在树根与树根父节点的连边也要剪掉。 感性理解一下，考虑为什么是对的。在原树上的任意一个子树都可以看成一棵树，树的根节点往上有一条链。先不考虑链，原问题变成了有一颗满 KKK 叉树，剪掉一些边使得 包含根节点 的联通分量大小为 xxx，求剪掉的边的最少条数。这个问题贪心地剪若干个最大的子树再递归下去显然是对的。上面的做发选择所有大小大于等于 XXX 的子树就实现了枚举链的长度，所以原贪心也是对的。 复杂度 O(D2)O(D^2)O(D2)。因为 1≤∑i=0DKi≤10181 \\leq \\displaystyle\\sum_{i=0}^D{K^i} \\leq 10^{18}1≤i=0∑D​Ki≤1018，所以 D≤60D \\leq 60D≤60，复杂度足以通过。 代码 闲话 考场写了个只选择最小的大小大于等于 XXX 的满 KKK 叉树，WA 了一发，然后在不知道为啥的情况下写了这个过了。"},{"title":"P3730 莫队+值域分块题解","date":"2023-02-18T16:00:00.000Z","url":"/posts/P3730/","tags":[["题解笔记","/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"],["莫队","/tags/%E8%8E%AB%E9%98%9F/"]],"categories":[["undefined",""]],"content":"“生きる熱さを感じたいだけさ”—— 《スリリング・ワンウェイ》 莫队+值域分块题解 题意简述 查询区间内出现次数第k小的值的出现次数。 1≤N,M≤1051\\leq N, M\\leq 10^51≤N,M≤105 题目分析 这种 1e51e51e5 又不带修改的规模容易想到莫队。但是使用平衡树之类 O(log⁡n)O(\\log n)O(logn) 插入 O(log⁡n)O(\\log n)O(logn) 查询的数据结构搭配莫队，会使复杂度变成 O(nnlog⁡n)O(n \\sqrt n \\log n)O(nn​logn)，无法通过此题。 考虑平衡复杂度，莫队有 nnn \\sqrt nnn​ 次插入和 nnn 次查询操作，所以我们最理想的情况下就是找到一个 O(1)O(1)O(1) 插入 O(n)O(\\sqrt n)O(n​) 查询的数据结构。值域分块 可以解决这个问题，此时总复杂度为 O(nn)O(n \\sqrt n)O(nn​)。 一些细节 题目值域是 [1,109][1,10^9][1,109]，需要离散化。 莫队的最优块长其实是 nm\\dfrac{n}{\\sqrt m}m​n​。因为 nnn 和 mmm 同价的时候和 n\\sqrt nn​ 是一样的，一般也没理这个事。证明详见 普通莫队算法 - Oi Wiki。 代码 后话 这种莫队套分块去平衡复杂度还挺常见的，有时候也搭配 bitset。 第一次写题解，水平有限还请见谅。 "}]